# This file was auto-generated by Fern from our API Definition.

import contextlib
import typing
from json.decoder import JSONDecodeError
from logging import error, warning

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.http_response import AsyncHttpResponse, HttpResponse
from .core.http_sse._api import EventSource
from .core.jsonable_encoder import jsonable_encoder
from .core.pydantic_utilities import parse_obj_as
from .core.request_options import RequestOptions
from .core.serialization import convert_and_respect_annotation_metadata
from .errors.bad_request_error import BadRequestError
from .types.active_session_response import ActiveSessionResponse
from .types.backup_environment_response import BackupEnvironmentResponse
from .types.cdp_url_response import CdpUrlResponse
from .types.close_environment_response import CloseEnvironmentResponse
from .types.create_sandbox_response import CreateSandboxResponse
from .types.create_snapshot_response import CreateSnapshotResponse
from .types.delete_sandbox_response import DeleteSandboxResponse
from .types.environment_state_response import EnvironmentStateResponse
from .types.error_response import ErrorResponse
from .types.evaluate_response import EvaluateResponse
from .types.heartbeat_response import HeartbeatResponse
from .types.job_status_response import JobStatusResponse
from .types.log_response import LogResponse
from .types.make_environment_response import MakeEnvironmentResponse
from .types.operation_event import OperationEvent
from .types.post_evaluation_result_response import PostEvaluationResultResponse
from .types.proxy_url_response import ProxyUrlResponse
from .types.reset_environment_response import ResetEnvironmentResponse
from .types.running_sessions_count_response import RunningSessionsCountResponse
from .types.setup_root_access_response import SetupRootAccessResponse
from .types.setup_sandbox_response import SetupSandboxResponse
from .types.sim_config_dataset import SimConfigDataset
from .types.simulator import Simulator
from .types.start_worker_response import StartWorkerResponse
from .types.test_cases_response import TestCasesResponse
from .types.worker_ready_response import WorkerReadyResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawApi:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def make_environment(
        self,
        *,
        interface_type: str,
        env_id: str,
        interface_width: typing.Optional[int] = OMIT,
        interface_height: typing.Optional[int] = OMIT,
        source: typing.Optional[str] = OMIT,
        open_page_on_start: typing.Optional[bool] = OMIT,
        tag: typing.Optional[str] = OMIT,
        dataset: typing.Optional[str] = OMIT,
        artifact_id: typing.Optional[str] = OMIT,
        env_config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        record_network_requests: typing.Optional[bool] = OMIT,
        record_actions: typing.Optional[bool] = OMIT,
        keepalive: typing.Optional[bool] = OMIT,
        alias: typing.Optional[str] = OMIT,
        fast: typing.Optional[bool] = OMIT,
        version: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[MakeEnvironmentResponse]:
        """
        Parameters
        ----------
        interface_type : str

        env_id : str

        interface_width : typing.Optional[int]

        interface_height : typing.Optional[int]

        source : typing.Optional[str]

        open_page_on_start : typing.Optional[bool]

        tag : typing.Optional[str]

        dataset : typing.Optional[str]

        artifact_id : typing.Optional[str]

        env_config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        record_network_requests : typing.Optional[bool]

        record_actions : typing.Optional[bool]

        keepalive : typing.Optional[bool]

        alias : typing.Optional[str]

        fast : typing.Optional[bool]

        version : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[MakeEnvironmentResponse]
            Environment created successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "env/make2",
            method="POST",
            json={
                "interface_type": interface_type,
                "interface_width": interface_width,
                "interface_height": interface_height,
                "source": source,
                "open_page_on_start": open_page_on_start,
                "env_id": env_id,
                "tag": tag,
                "dataset": dataset,
                "artifact_id": artifact_id,
                "env_config": env_config,
                "record_network_requests": record_network_requests,
                "record_actions": record_actions,
                "keepalive": keepalive,
                "alias": alias,
                "fast": fast,
                "version": version,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MakeEnvironmentResponse,
                    parse_obj_as(
                        type_=MakeEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_job_status(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[JobStatusResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[JobStatusResponse]
            Job status retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    JobStatusResponse,
                    parse_obj_as(
                        type_=JobStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_cdp_url(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CdpUrlResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CdpUrlResponse]
            CDP URL retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/cdp_url",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CdpUrlResponse,
                    parse_obj_as(
                        type_=CdpUrlResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_proxy_url(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ProxyUrlResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ProxyUrlResponse]
            Proxy URL retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/proxy_url",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProxyUrlResponse,
                    parse_obj_as(
                        type_=ProxyUrlResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def close_environment(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CloseEnvironmentResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CloseEnvironmentResponse]
            Environment closed successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/close",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CloseEnvironmentResponse,
                    parse_obj_as(
                        type_=CloseEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def backup_environment(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[BackupEnvironmentResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BackupEnvironmentResponse]
            Environment backed up successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/backup",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BackupEnvironmentResponse,
                    parse_obj_as(
                        type_=BackupEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def reset_environment(
        self,
        job_id: str,
        *,
        test_case_public_id: typing.Optional[str] = OMIT,
        agent_version: typing.Optional[str] = OMIT,
        load_browser_state: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ResetEnvironmentResponse]:
        """
        Parameters
        ----------
        job_id : str

        test_case_public_id : typing.Optional[str]

        agent_version : typing.Optional[str]

        load_browser_state : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ResetEnvironmentResponse]
            Environment reset successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/reset",
            method="POST",
            json={
                "test_case_public_id": test_case_public_id,
                "agent_version": agent_version,
                "load_browser_state": load_browser_state,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ResetEnvironmentResponse,
                    parse_obj_as(
                        type_=ResetEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_environment_state(
        self,
        job_id: str,
        *,
        merge_mutations: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EnvironmentStateResponse]:
        """
        Parameters
        ----------
        job_id : str

        merge_mutations : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EnvironmentStateResponse]
            Environment state retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/state",
            method="GET",
            params={
                "merge_mutations": merge_mutations,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EnvironmentStateResponse,
                    parse_obj_as(
                        type_=EnvironmentStateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_worker_ready(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[WorkerReadyResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[WorkerReadyResponse]
            Worker ready status retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/worker_ready",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkerReadyResponse,
                    parse_obj_as(
                        type_=WorkerReadyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def send_heartbeat(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[HeartbeatResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[HeartbeatResponse]
            Heartbeat sent successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/heartbeat",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    HeartbeatResponse,
                    parse_obj_as(
                        type_=HeartbeatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_active_session(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[ActiveSessionResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ActiveSessionResponse]
            Active session retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/active_session",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActiveSessionResponse,
                    parse_obj_as(
                        type_=ActiveSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def evaluate_session(
        self,
        session_id: str,
        *,
        value: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[EvaluateResponse]:
        """
        Parameters
        ----------
        session_id : str

        value : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[EvaluateResponse]
            Evaluation completed successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/session/{jsonable_encoder(session_id)}/evaluate",
            method="POST",
            json={
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluateResponse,
                    parse_obj_as(
                        type_=EvaluateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post_evaluation_result(
        self,
        session_id: str,
        *,
        success: bool,
        reason: typing.Optional[str] = OMIT,
        agent_version: typing.Optional[str] = OMIT,
        mutations: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PostEvaluationResultResponse]:
        """
        Parameters
        ----------
        session_id : str

        success : bool

        reason : typing.Optional[str]

        agent_version : typing.Optional[str]

        mutations : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PostEvaluationResultResponse]
            Evaluation result posted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/session/{jsonable_encoder(session_id)}/score",
            method="POST",
            json={
                "success": success,
                "reason": reason,
                "agent_version": agent_version,
                "mutations": mutations,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostEvaluationResultResponse,
                    parse_obj_as(
                        type_=PostEvaluationResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def log_message(
        self,
        session_id: str,
        *,
        source: str,
        type: str,
        message: typing.Dict[str, typing.Optional[typing.Any]],
        timestamp: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[LogResponse]:
        """
        Parameters
        ----------
        session_id : str

        source : str

        type : str

        message : typing.Dict[str, typing.Optional[typing.Any]]

        timestamp : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[LogResponse]
            Log message sent successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(session_id)}/log",
            method="POST",
            json={
                "source": source,
                "type": type,
                "message": message,
                "timestamp": timestamp,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LogResponse,
                    parse_obj_as(
                        type_=LogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list_simulators(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[typing.List[Simulator]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[Simulator]]
            Simulators retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "env/simulators",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Simulator],
                    parse_obj_as(
                        type_=typing.List[Simulator],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_test_cases(
        self,
        *,
        simulator_name: typing.Optional[str] = None,
        simulator_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TestCasesResponse]:
        """
        Parameters
        ----------
        simulator_name : typing.Optional[str]

        simulator_id : typing.Optional[str]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TestCasesResponse]
            Test cases retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "testcases",
            method="GET",
            params={
                "simulator_name": simulator_name,
                "simulator_id": simulator_id,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TestCasesResponse,
                    parse_obj_as(
                        type_=TestCasesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def get_running_sessions_count(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[RunningSessionsCountResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[RunningSessionsCountResponse]
            Running sessions count retrieved successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            "user/organization/running-sessions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RunningSessionsCountResponse,
                    parse_obj_as(
                        type_=RunningSessionsCountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    @contextlib.contextmanager
    def monitor_operation(
        self, correlation_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Iterator[HttpResponse[typing.Iterator[OperationEvent]]]:
        """
        Monitor the progress of long-running operations (sandbox creation, setup, etc.) via SSE.

        **Event Flow:**
        1. First event: `type: "connected"` - Connection established, continue listening
        2. Progress events: `type: "progress"` with `message` field - Operation updates
        3. Completion: `type: "run_result"` or `"ssh_result"` - Operation finished
           - Check `success: true` for successful completion
           - Check `error` or `message` field if `success: false`
        4. Error: `type: "error"` - Operation failed, check `error` or `message` field

        **Data Format:**
        SSE data is base64-encoded JSON. Decode it to get the OperationEvent object.

        **Client Implementation Required:**
        - Decode base64 data from each SSE event
        - Parse JSON to OperationEvent
        - Check event.type and event.success to determine operation status
        - Continue listening until receiving a terminal event (run_result, ssh_result, or error)
        - Return success/error based on the terminal event

        **Example (pseudo-code):**
        ```
        for event in stream:
          decoded = base64_decode(event.data)
          operation_event = json_parse(decoded)

          if operation_event.type == "connected":
            continue  # Keep listening
          elif operation_event.type in ["run_result", "ssh_result"]:
            if operation_event.success:
              return SUCCESS
            else:
              return ERROR(operation_event.error || operation_event.message)
          elif operation_event.type == "error":
            return ERROR(operation_event.error || operation_event.message)
        ```

        Parameters
        ----------
        correlation_id : str
            Correlation ID from sandbox creation or setup operation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[HttpResponse[typing.Iterator[OperationEvent]]]
            SSE stream of operation events
        """
        with self._client_wrapper.httpx_client.stream(
            f"public-build/events/{jsonable_encoder(correlation_id)}",
            method="GET",
            request_options=request_options,
        ) as _response:

            def _stream() -> HttpResponse[typing.Iterator[OperationEvent]]:
                try:
                    if 200 <= _response.status_code < 300:

                        def _iter():
                            _event_source = EventSource(_response)
                            for _sse in _event_source.iter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield typing.cast(
                                        OperationEvent,
                                        parse_obj_as(
                                            type_=OperationEvent,  # type: ignore
                                            object_=_sse.json(),
                                        ),
                                    )
                                except JSONDecodeError as e:
                                    warning(f"Skipping SSE event with invalid JSON: {e}, sse: {_sse!r}")
                                except (TypeError, ValueError, KeyError, AttributeError) as e:
                                    warning(
                                        f"Skipping SSE event due to model construction error: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                                except Exception as e:
                                    error(
                                        f"Unexpected error processing SSE event: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                            return

                        return HttpResponse(response=_response, data=_iter())
                    _response.read()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                ErrorResponse,
                                parse_obj_as(
                                    type_=ErrorResponse,  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
                    )
                raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

            yield _stream()

    def create_sandbox(
        self,
        *,
        dataset: str,
        plato_dataset_config: SimConfigDataset,
        timeout: typing.Optional[int] = OMIT,
        wait_time: typing.Optional[int] = OMIT,
        alias: typing.Optional[str] = OMIT,
        artifact_id: typing.Optional[str] = OMIT,
        service: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateSandboxResponse]:
        """
        Parameters
        ----------
        dataset : str
            Dataset name (e.g., "base")

        plato_dataset_config : SimConfigDataset

        timeout : typing.Optional[int]
            Timeout in seconds for sandbox creation

        wait_time : typing.Optional[int]
            Wait time in seconds

        alias : typing.Optional[str]
            Human-readable alias for the sandbox

        artifact_id : typing.Optional[str]
            Optional artifact ID to create sandbox from snapshot

        service : typing.Optional[str]
            Service name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateSandboxResponse]
            Sandbox creation initiated successfully
        """
        input_json = {
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "timeout": timeout,
                "wait_time": wait_time,
                "alias": alias,
                "artifact_id": artifact_id,
                "service": service,
            }
        print(f"input_json: {input_json}")
        _response = self._client_wrapper.httpx_client.request(
            "public-build/vm/create",
            method="POST",
            json={
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "timeout": timeout,
                "wait_time": wait_time,
                "alias": alias,
                "artifact_id": artifact_id,
                "service": service,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSandboxResponse,
                    parse_obj_as(
                        type_=CreateSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def setup_sandbox(
        self,
        job_id: str,
        *,
        dataset: str,
        plato_dataset_config: SimConfigDataset,
        ssh_public_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SetupSandboxResponse]:
        """
        Parameters
        ----------
        job_id : str

        dataset : str
            Dataset name

        plato_dataset_config : SimConfigDataset

        ssh_public_key : typing.Optional[str]
            SSH public key to install for plato user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SetupSandboxResponse]
            Sandbox setup initiated successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(job_id)}/setup-sandbox",
            method="POST",
            json={
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "ssh_public_key": ssh_public_key,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SetupSandboxResponse,
                    parse_obj_as(
                        type_=SetupSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def delete_sandbox(
        self, public_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[DeleteSandboxResponse]:
        """
        Parameters
        ----------
        public_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[DeleteSandboxResponse]
            Sandbox deleted successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteSandboxResponse,
                    parse_obj_as(
                        type_=DeleteSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_snapshot(
        self,
        public_id: str,
        *,
        service: typing.Optional[str] = OMIT,
        git_hash: typing.Optional[str] = OMIT,
        dataset: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateSnapshotResponse]:
        """
        Parameters
        ----------
        public_id : str

        service : typing.Optional[str]

        git_hash : typing.Optional[str]

        dataset : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateSnapshotResponse]
            Snapshot created successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}/snapshot",
            method="POST",
            json={
                "service": service,
                "git_hash": git_hash,
                "dataset": dataset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSnapshotResponse,
                    parse_obj_as(
                        type_=CreateSnapshotResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def start_worker(
        self,
        public_id: str,
        *,
        dataset: str,
        plato_dataset_config: SimConfigDataset,
        service: typing.Optional[str] = OMIT,
        timeout: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[StartWorkerResponse]:
        """
        Parameters
        ----------
        public_id : str

        dataset : str

        plato_dataset_config : SimConfigDataset

        service : typing.Optional[str]

        timeout : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[StartWorkerResponse]
            Worker started successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}/start-worker",
            method="POST",
            json={
                "service": service,
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "timeout": timeout,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StartWorkerResponse,
                    parse_obj_as(
                        type_=StartWorkerResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def setup_root_access(
        self,
        public_id: str,
        *,
        ssh_public_key: str,
        timeout: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SetupRootAccessResponse]:
        """
        Parameters
        ----------
        public_id : str

        ssh_public_key : str
            SSH public key to install for root user

        timeout : typing.Optional[int]
            Timeout in seconds

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SetupRootAccessResponse]
            Root access setup successfully
        """
        _response = self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}/setup-root-access",
            method="POST",
            json={
                "ssh_public_key": ssh_public_key,
                "timeout": timeout,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SetupRootAccessResponse,
                    parse_obj_as(
                        type_=SetupRootAccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawApi:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def make_environment(
        self,
        *,
        interface_type: str,
        env_id: str,
        interface_width: typing.Optional[int] = OMIT,
        interface_height: typing.Optional[int] = OMIT,
        source: typing.Optional[str] = OMIT,
        open_page_on_start: typing.Optional[bool] = OMIT,
        tag: typing.Optional[str] = OMIT,
        dataset: typing.Optional[str] = OMIT,
        artifact_id: typing.Optional[str] = OMIT,
        env_config: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        record_network_requests: typing.Optional[bool] = OMIT,
        record_actions: typing.Optional[bool] = OMIT,
        keepalive: typing.Optional[bool] = OMIT,
        alias: typing.Optional[str] = OMIT,
        fast: typing.Optional[bool] = OMIT,
        version: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[MakeEnvironmentResponse]:
        """
        Parameters
        ----------
        interface_type : str

        env_id : str

        interface_width : typing.Optional[int]

        interface_height : typing.Optional[int]

        source : typing.Optional[str]

        open_page_on_start : typing.Optional[bool]

        tag : typing.Optional[str]

        dataset : typing.Optional[str]

        artifact_id : typing.Optional[str]

        env_config : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        record_network_requests : typing.Optional[bool]

        record_actions : typing.Optional[bool]

        keepalive : typing.Optional[bool]

        alias : typing.Optional[str]

        fast : typing.Optional[bool]

        version : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[MakeEnvironmentResponse]
            Environment created successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "env/make2",
            method="POST",
            json={
                "interface_type": interface_type,
                "interface_width": interface_width,
                "interface_height": interface_height,
                "source": source,
                "open_page_on_start": open_page_on_start,
                "env_id": env_id,
                "tag": tag,
                "dataset": dataset,
                "artifact_id": artifact_id,
                "env_config": env_config,
                "record_network_requests": record_network_requests,
                "record_actions": record_actions,
                "keepalive": keepalive,
                "alias": alias,
                "fast": fast,
                "version": version,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    MakeEnvironmentResponse,
                    parse_obj_as(
                        type_=MakeEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_job_status(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[JobStatusResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[JobStatusResponse]
            Job status retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    JobStatusResponse,
                    parse_obj_as(
                        type_=JobStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_cdp_url(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CdpUrlResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CdpUrlResponse]
            CDP URL retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/cdp_url",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CdpUrlResponse,
                    parse_obj_as(
                        type_=CdpUrlResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_proxy_url(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ProxyUrlResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ProxyUrlResponse]
            Proxy URL retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/proxy_url",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ProxyUrlResponse,
                    parse_obj_as(
                        type_=ProxyUrlResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def close_environment(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CloseEnvironmentResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CloseEnvironmentResponse]
            Environment closed successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/close",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CloseEnvironmentResponse,
                    parse_obj_as(
                        type_=CloseEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def backup_environment(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[BackupEnvironmentResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BackupEnvironmentResponse]
            Environment backed up successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/backup",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BackupEnvironmentResponse,
                    parse_obj_as(
                        type_=BackupEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def reset_environment(
        self,
        job_id: str,
        *,
        test_case_public_id: typing.Optional[str] = OMIT,
        agent_version: typing.Optional[str] = OMIT,
        load_browser_state: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ResetEnvironmentResponse]:
        """
        Parameters
        ----------
        job_id : str

        test_case_public_id : typing.Optional[str]

        agent_version : typing.Optional[str]

        load_browser_state : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ResetEnvironmentResponse]
            Environment reset successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/reset",
            method="POST",
            json={
                "test_case_public_id": test_case_public_id,
                "agent_version": agent_version,
                "load_browser_state": load_browser_state,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ResetEnvironmentResponse,
                    parse_obj_as(
                        type_=ResetEnvironmentResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_environment_state(
        self,
        job_id: str,
        *,
        merge_mutations: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EnvironmentStateResponse]:
        """
        Parameters
        ----------
        job_id : str

        merge_mutations : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EnvironmentStateResponse]
            Environment state retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/state",
            method="GET",
            params={
                "merge_mutations": merge_mutations,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EnvironmentStateResponse,
                    parse_obj_as(
                        type_=EnvironmentStateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_worker_ready(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[WorkerReadyResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[WorkerReadyResponse]
            Worker ready status retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/worker_ready",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    WorkerReadyResponse,
                    parse_obj_as(
                        type_=WorkerReadyResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def send_heartbeat(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[HeartbeatResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[HeartbeatResponse]
            Heartbeat sent successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/heartbeat",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    HeartbeatResponse,
                    parse_obj_as(
                        type_=HeartbeatResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_active_session(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[ActiveSessionResponse]:
        """
        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ActiveSessionResponse]
            Active session retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(job_id)}/active_session",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ActiveSessionResponse,
                    parse_obj_as(
                        type_=ActiveSessionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def evaluate_session(
        self,
        session_id: str,
        *,
        value: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[EvaluateResponse]:
        """
        Parameters
        ----------
        session_id : str

        value : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[EvaluateResponse]
            Evaluation completed successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/session/{jsonable_encoder(session_id)}/evaluate",
            method="POST",
            json={
                "value": value,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    EvaluateResponse,
                    parse_obj_as(
                        type_=EvaluateResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post_evaluation_result(
        self,
        session_id: str,
        *,
        success: bool,
        reason: typing.Optional[str] = OMIT,
        agent_version: typing.Optional[str] = OMIT,
        mutations: typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PostEvaluationResultResponse]:
        """
        Parameters
        ----------
        session_id : str

        success : bool

        reason : typing.Optional[str]

        agent_version : typing.Optional[str]

        mutations : typing.Optional[typing.Sequence[typing.Dict[str, typing.Optional[typing.Any]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PostEvaluationResultResponse]
            Evaluation result posted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/session/{jsonable_encoder(session_id)}/score",
            method="POST",
            json={
                "success": success,
                "reason": reason,
                "agent_version": agent_version,
                "mutations": mutations,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PostEvaluationResultResponse,
                    parse_obj_as(
                        type_=PostEvaluationResultResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def log_message(
        self,
        session_id: str,
        *,
        source: str,
        type: str,
        message: typing.Dict[str, typing.Optional[typing.Any]],
        timestamp: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[LogResponse]:
        """
        Parameters
        ----------
        session_id : str

        source : str

        type : str

        message : typing.Dict[str, typing.Optional[typing.Any]]

        timestamp : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[LogResponse]
            Log message sent successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"env/{jsonable_encoder(session_id)}/log",
            method="POST",
            json={
                "source": source,
                "type": type,
                "message": message,
                "timestamp": timestamp,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    LogResponse,
                    parse_obj_as(
                        type_=LogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list_simulators(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[typing.List[Simulator]]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[Simulator]]
            Simulators retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "env/simulators",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[Simulator],
                    parse_obj_as(
                        type_=typing.List[Simulator],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_test_cases(
        self,
        *,
        simulator_name: typing.Optional[str] = None,
        simulator_id: typing.Optional[str] = None,
        page_size: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TestCasesResponse]:
        """
        Parameters
        ----------
        simulator_name : typing.Optional[str]

        simulator_id : typing.Optional[str]

        page_size : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TestCasesResponse]
            Test cases retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "testcases",
            method="GET",
            params={
                "simulator_name": simulator_name,
                "simulator_id": simulator_id,
                "page_size": page_size,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TestCasesResponse,
                    parse_obj_as(
                        type_=TestCasesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def get_running_sessions_count(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[RunningSessionsCountResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[RunningSessionsCountResponse]
            Running sessions count retrieved successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "user/organization/running-sessions",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    RunningSessionsCountResponse,
                    parse_obj_as(
                        type_=RunningSessionsCountResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    @contextlib.asynccontextmanager
    async def monitor_operation(
        self, correlation_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[OperationEvent]]]:
        """
        Monitor the progress of long-running operations (sandbox creation, setup, etc.) via SSE.

        **Event Flow:**
        1. First event: `type: "connected"` - Connection established, continue listening
        2. Progress events: `type: "progress"` with `message` field - Operation updates
        3. Completion: `type: "run_result"` or `"ssh_result"` - Operation finished
           - Check `success: true` for successful completion
           - Check `error` or `message` field if `success: false`
        4. Error: `type: "error"` - Operation failed, check `error` or `message` field

        **Data Format:**
        SSE data is base64-encoded JSON. Decode it to get the OperationEvent object.

        **Client Implementation Required:**
        - Decode base64 data from each SSE event
        - Parse JSON to OperationEvent
        - Check event.type and event.success to determine operation status
        - Continue listening until receiving a terminal event (run_result, ssh_result, or error)
        - Return success/error based on the terminal event

        **Example (pseudo-code):**
        ```
        for event in stream:
          decoded = base64_decode(event.data)
          operation_event = json_parse(decoded)

          if operation_event.type == "connected":
            continue  # Keep listening
          elif operation_event.type in ["run_result", "ssh_result"]:
            if operation_event.success:
              return SUCCESS
            else:
              return ERROR(operation_event.error || operation_event.message)
          elif operation_event.type == "error":
            return ERROR(operation_event.error || operation_event.message)
        ```

        Parameters
        ----------
        correlation_id : str
            Correlation ID from sandbox creation or setup operation

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[AsyncHttpResponse[typing.AsyncIterator[OperationEvent]]]
            SSE stream of operation events
        """
        async with self._client_wrapper.httpx_client.stream(
            f"public-build/events/{jsonable_encoder(correlation_id)}",
            method="GET",
            request_options=request_options,
        ) as _response:

            async def _stream() -> AsyncHttpResponse[typing.AsyncIterator[OperationEvent]]:
                try:
                    if 200 <= _response.status_code < 300:

                        async def _iter():
                            _event_source = EventSource(_response)
                            async for _sse in _event_source.aiter_sse():
                                if _sse.data == None:
                                    return
                                try:
                                    yield typing.cast(
                                        OperationEvent,
                                        parse_obj_as(
                                            type_=OperationEvent,  # type: ignore
                                            object_=_sse.json(),
                                        ),
                                    )
                                except JSONDecodeError as e:
                                    warning(f"Skipping SSE event with invalid JSON: {e}, sse: {_sse!r}")
                                except (TypeError, ValueError, KeyError, AttributeError) as e:
                                    warning(
                                        f"Skipping SSE event due to model construction error: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                                except Exception as e:
                                    error(
                                        f"Unexpected error processing SSE event: {type(e).__name__}: {e}, sse: {_sse!r}"
                                    )
                            return

                        return AsyncHttpResponse(response=_response, data=_iter())
                    await _response.aread()
                    if _response.status_code == 400:
                        raise BadRequestError(
                            headers=dict(_response.headers),
                            body=typing.cast(
                                ErrorResponse,
                                parse_obj_as(
                                    type_=ErrorResponse,  # type: ignore
                                    object_=_response.json(),
                                ),
                            ),
                        )
                    _response_json = _response.json()
                except JSONDecodeError:
                    raise ApiError(
                        status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
                    )
                raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

            yield await _stream()

    async def create_sandbox(
        self,
        *,
        dataset: str,
        plato_dataset_config: SimConfigDataset,
        timeout: typing.Optional[int] = OMIT,
        wait_time: typing.Optional[int] = OMIT,
        alias: typing.Optional[str] = OMIT,
        artifact_id: typing.Optional[str] = OMIT,
        service: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateSandboxResponse]:
        """
        Parameters
        ----------
        dataset : str
            Dataset name (e.g., "base")

        plato_dataset_config : SimConfigDataset

        timeout : typing.Optional[int]
            Timeout in seconds for sandbox creation

        wait_time : typing.Optional[int]
            Wait time in seconds

        alias : typing.Optional[str]
            Human-readable alias for the sandbox

        artifact_id : typing.Optional[str]
            Optional artifact ID to create sandbox from snapshot

        service : typing.Optional[str]
            Service name

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateSandboxResponse]
            Sandbox creation initiated successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            "public-build/vm/create",
            method="POST",
            json={
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "timeout": timeout,
                "wait_time": wait_time,
                "alias": alias,
                "artifact_id": artifact_id,
                "service": service,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSandboxResponse,
                    parse_obj_as(
                        type_=CreateSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def setup_sandbox(
        self,
        job_id: str,
        *,
        dataset: str,
        plato_dataset_config: SimConfigDataset,
        ssh_public_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SetupSandboxResponse]:
        """
        Parameters
        ----------
        job_id : str

        dataset : str
            Dataset name

        plato_dataset_config : SimConfigDataset

        ssh_public_key : typing.Optional[str]
            SSH public key to install for plato user

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SetupSandboxResponse]
            Sandbox setup initiated successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(job_id)}/setup-sandbox",
            method="POST",
            json={
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "ssh_public_key": ssh_public_key,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SetupSandboxResponse,
                    parse_obj_as(
                        type_=SetupSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def delete_sandbox(
        self, public_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[DeleteSandboxResponse]:
        """
        Parameters
        ----------
        public_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[DeleteSandboxResponse]
            Sandbox deleted successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    DeleteSandboxResponse,
                    parse_obj_as(
                        type_=DeleteSandboxResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_snapshot(
        self,
        public_id: str,
        *,
        service: typing.Optional[str] = OMIT,
        git_hash: typing.Optional[str] = OMIT,
        dataset: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateSnapshotResponse]:
        """
        Parameters
        ----------
        public_id : str

        service : typing.Optional[str]

        git_hash : typing.Optional[str]

        dataset : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateSnapshotResponse]
            Snapshot created successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}/snapshot",
            method="POST",
            json={
                "service": service,
                "git_hash": git_hash,
                "dataset": dataset,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateSnapshotResponse,
                    parse_obj_as(
                        type_=CreateSnapshotResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def start_worker(
        self,
        public_id: str,
        *,
        dataset: str,
        plato_dataset_config: SimConfigDataset,
        service: typing.Optional[str] = OMIT,
        timeout: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[StartWorkerResponse]:
        """
        Parameters
        ----------
        public_id : str

        dataset : str

        plato_dataset_config : SimConfigDataset

        service : typing.Optional[str]

        timeout : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[StartWorkerResponse]
            Worker started successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}/start-worker",
            method="POST",
            json={
                "service": service,
                "dataset": dataset,
                "plato_dataset_config": convert_and_respect_annotation_metadata(
                    object_=plato_dataset_config, annotation=SimConfigDataset, direction="write"
                ),
                "timeout": timeout,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    StartWorkerResponse,
                    parse_obj_as(
                        type_=StartWorkerResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def setup_root_access(
        self,
        public_id: str,
        *,
        ssh_public_key: str,
        timeout: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SetupRootAccessResponse]:
        """
        Parameters
        ----------
        public_id : str

        ssh_public_key : str
            SSH public key to install for root user

        timeout : typing.Optional[int]
            Timeout in seconds

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SetupRootAccessResponse]
            Root access setup successfully
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"public-build/vm/{jsonable_encoder(public_id)}/setup-root-access",
            method="POST",
            json={
                "ssh_public_key": ssh_public_key,
                "timeout": timeout,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SetupRootAccessResponse,
                    parse_obj_as(
                        type_=SetupRootAccessResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ErrorResponse,
                        parse_obj_as(
                            type_=ErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
