// Code generated by Fern. DO NOT EDIT.

package client

import (
	context "context"
	http "net/http"
	sdk "sdk"
	core "sdk/core"
	internal "sdk/internal"
	option "sdk/option"
)

type Client struct {
	WithRawResponse *RawClient

	options *core.RequestOptions
	baseURL string
	caller  *internal.Caller
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	return &Client{
		WithRawResponse: NewRawClient(options),
		options:         options,
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
	}
}

func (c *Client) MakeEnvironment(
	ctx context.Context,
	request *sdk.MakeEnvironmentRequest,
	opts ...option.RequestOption,
) (*sdk.MakeEnvironmentResponse, error) {
	response, err := c.WithRawResponse.MakeEnvironment(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetJobStatus(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.JobStatusResponse, error) {
	response, err := c.WithRawResponse.GetJobStatus(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetCdpUrl(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.CdpUrlResponse, error) {
	response, err := c.WithRawResponse.GetCdpUrl(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetProxyUrl(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.ProxyUrlResponse, error) {
	response, err := c.WithRawResponse.GetProxyUrl(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) CloseEnvironment(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.CloseEnvironmentResponse, error) {
	response, err := c.WithRawResponse.CloseEnvironment(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) BackupEnvironment(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.BackupEnvironmentResponse, error) {
	response, err := c.WithRawResponse.BackupEnvironment(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ResetEnvironment(
	ctx context.Context,
	jobId string,
	request *sdk.ResetEnvironmentRequest,
	opts ...option.RequestOption,
) (*sdk.ResetEnvironmentResponse, error) {
	response, err := c.WithRawResponse.ResetEnvironment(
		ctx,
		jobId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetEnvironmentState(
	ctx context.Context,
	jobId string,
	request *sdk.GetEnvironmentStateRequest,
	opts ...option.RequestOption,
) (*sdk.EnvironmentStateResponse, error) {
	response, err := c.WithRawResponse.GetEnvironmentState(
		ctx,
		jobId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetWorkerReady(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.WorkerReadyResponse, error) {
	response, err := c.WithRawResponse.GetWorkerReady(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) SendHeartbeat(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.HeartbeatResponse, error) {
	response, err := c.WithRawResponse.SendHeartbeat(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetActiveSession(
	ctx context.Context,
	jobId string,
	opts ...option.RequestOption,
) (*sdk.ActiveSessionResponse, error) {
	response, err := c.WithRawResponse.GetActiveSession(
		ctx,
		jobId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) EvaluateSession(
	ctx context.Context,
	sessionId string,
	request *sdk.EvaluateRequest,
	opts ...option.RequestOption,
) (*sdk.EvaluateResponse, error) {
	response, err := c.WithRawResponse.EvaluateSession(
		ctx,
		sessionId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) PostEvaluationResult(
	ctx context.Context,
	sessionId string,
	request *sdk.PostEvaluationResultRequest,
	opts ...option.RequestOption,
) (*sdk.PostEvaluationResultResponse, error) {
	response, err := c.WithRawResponse.PostEvaluationResult(
		ctx,
		sessionId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) LogMessage(
	ctx context.Context,
	sessionId string,
	request *sdk.LogRequest,
	opts ...option.RequestOption,
) (*sdk.LogResponse, error) {
	response, err := c.WithRawResponse.LogMessage(
		ctx,
		sessionId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) ListSimulators(
	ctx context.Context,
	opts ...option.RequestOption,
) ([]*sdk.Simulator, error) {
	response, err := c.WithRawResponse.ListSimulators(
		ctx,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetTestCases(
	ctx context.Context,
	request *sdk.GetTestCasesRequest,
	opts ...option.RequestOption,
) (*sdk.TestCasesResponse, error) {
	response, err := c.WithRawResponse.GetTestCases(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) GetRunningSessionsCount(
	ctx context.Context,
	opts ...option.RequestOption,
) (*sdk.RunningSessionsCountResponse, error) {
	response, err := c.WithRawResponse.GetRunningSessionsCount(
		ctx,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Monitor the progress of long-running operations (sandbox creation, setup, etc.) via SSE.
//
// **Event Flow:**
// 1. First event: `type: "connected"` - Connection established, continue listening
// 2. Progress events: `type: "progress"` with `message` field - Operation updates
// 3. Completion: `type: "run_result"` or `"ssh_result"` - Operation finished
//   - Check `success: true` for successful completion
//   - Check `error` or `message` field if `success: false`
//
// 4. Error: `type: "error"` - Operation failed, check `error` or `message` field
//
// **Data Format:**
// SSE data is base64-encoded JSON. Decode it to get the OperationEvent object.
//
// **Client Implementation Required:**
// - Decode base64 data from each SSE event
// - Parse JSON to OperationEvent
// - Check event.type and event.success to determine operation status
// - Continue listening until receiving a terminal event (run_result, ssh_result, or error)
// - Return success/error based on the terminal event
//
// **Example (pseudo-code):**
// ```
// for event in stream:
//
//	decoded = base64_decode(event.data)
//	operation_event = json_parse(decoded)
//
//	if operation_event.type == "connected":
//	  continue  # Keep listening
//	elif operation_event.type in ["run_result", "ssh_result"]:
//	  if operation_event.success:
//	    return SUCCESS
//	  else:
//	    return ERROR(operation_event.error || operation_event.message)
//	elif operation_event.type == "error":
//	  return ERROR(operation_event.error || operation_event.message)
//
// ```
func (c *Client) MonitorOperation(
	ctx context.Context,
	// Correlation ID from sandbox creation or setup operation
	correlationId string,
	opts ...option.RequestOption,
) (*core.Stream[sdk.OperationEvent], error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/public-build/events/%v",
		correlationId,
	)
	headers := internal.MergeHeaders(
		c.options.ToHeader(),
		options.ToHeader(),
	)
	headers.Add("Accept", "text/event-stream")
	streamer := internal.NewStreamer[sdk.OperationEvent](c.caller)
	return streamer.Stream(
		ctx,
		&internal.StreamParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Prefix:          internal.DefaultSSEDataPrefix,
			Terminator:      internal.DefaultSSETerminator,
			Format:          core.StreamFormatSSE,
			ErrorDecoder:    internal.NewErrorDecoder(sdk.ErrorCodes),
		},
	)
}

func (c *Client) CreateSandbox(
	ctx context.Context,
	request *sdk.CreateSandboxRequest,
	opts ...option.RequestOption,
) (*sdk.CreateSandboxResponse, error) {
	response, err := c.WithRawResponse.CreateSandbox(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) SetupSandbox(
	ctx context.Context,
	jobId string,
	request *sdk.SetupSandboxRequest,
	opts ...option.RequestOption,
) (*sdk.SetupSandboxResponse, error) {
	response, err := c.WithRawResponse.SetupSandbox(
		ctx,
		jobId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) DeleteSandbox(
	ctx context.Context,
	publicId string,
	opts ...option.RequestOption,
) (*sdk.DeleteSandboxResponse, error) {
	response, err := c.WithRawResponse.DeleteSandbox(
		ctx,
		publicId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) CreateSnapshot(
	ctx context.Context,
	publicId string,
	request *sdk.CreateSnapshotRequest,
	opts ...option.RequestOption,
) (*sdk.CreateSnapshotResponse, error) {
	response, err := c.WithRawResponse.CreateSnapshot(
		ctx,
		publicId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) StartWorker(
	ctx context.Context,
	publicId string,
	request *sdk.StartWorkerRequest,
	opts ...option.RequestOption,
) (*sdk.StartWorkerResponse, error) {
	response, err := c.WithRawResponse.StartWorker(
		ctx,
		publicId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

func (c *Client) SetupRootAccess(
	ctx context.Context,
	publicId string,
	request *sdk.SetupRootAccessRequest,
	opts ...option.RequestOption,
) (*sdk.SetupRootAccessResponse, error) {
	response, err := c.WithRawResponse.SetupRootAccess(
		ctx,
		publicId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}
