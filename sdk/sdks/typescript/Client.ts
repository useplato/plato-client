// This file was auto-generated by Fern from our API Definition.

import * as Api from "./api/index.js";
import type { BaseClientOptions, BaseRequestOptions } from "./BaseClient.js";
import { mergeHeaders } from "./core/headers.js";
import * as core from "./core/index.js";
import * as errors from "./errors/index.js";

export declare namespace ApiClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ApiClient {
    protected readonly _options: ApiClient.Options;

    constructor(_options: ApiClient.Options) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    /**
     * @param {Api.MakeEnvironmentRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.makeEnvironment({
     *         interface_type: "interface_type",
     *         env_id: "env_id"
     *     })
     */
    public makeEnvironment(
        request: Api.MakeEnvironmentRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.MakeEnvironmentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__makeEnvironment(request, requestOptions));
    }

    private async __makeEnvironment(
        request: Api.MakeEnvironmentRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.MakeEnvironmentResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "env/make2",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.MakeEnvironmentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/make2.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getJobStatus("job_id")
     */
    public getJobStatus(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.JobStatusResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getJobStatus(jobId, requestOptions));
    }

    private async __getJobStatus(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.JobStatusResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/status`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.JobStatusResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/{job_id}/status.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getCdpUrl("job_id")
     */
    public getCdpUrl(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.CdpUrlResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getCdpUrl(jobId, requestOptions));
    }

    private async __getCdpUrl(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.CdpUrlResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/cdp_url`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.CdpUrlResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/{job_id}/cdp_url.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getProxyUrl("job_id")
     */
    public getProxyUrl(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.ProxyUrlResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getProxyUrl(jobId, requestOptions));
    }

    private async __getProxyUrl(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.ProxyUrlResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/proxy_url`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.ProxyUrlResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/{job_id}/proxy_url.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.closeEnvironment("job_id")
     */
    public closeEnvironment(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.CloseEnvironmentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__closeEnvironment(jobId, requestOptions));
    }

    private async __closeEnvironment(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.CloseEnvironmentResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/close`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.CloseEnvironmentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/{job_id}/close.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.backupEnvironment("job_id")
     */
    public backupEnvironment(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.BackupEnvironmentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__backupEnvironment(jobId, requestOptions));
    }

    private async __backupEnvironment(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.BackupEnvironmentResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/backup`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.BackupEnvironmentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/{job_id}/backup.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {Api.ResetEnvironmentRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.resetEnvironment("job_id")
     */
    public resetEnvironment(
        jobId: string,
        request: Api.ResetEnvironmentRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.ResetEnvironmentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__resetEnvironment(jobId, request, requestOptions));
    }

    private async __resetEnvironment(
        jobId: string,
        request: Api.ResetEnvironmentRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.ResetEnvironmentResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/reset`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.ResetEnvironmentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/{job_id}/reset.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {Api.GetEnvironmentStateRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getEnvironmentState("job_id", {
     *         merge_mutations: true
     *     })
     */
    public getEnvironmentState(
        jobId: string,
        request: Api.GetEnvironmentStateRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.EnvironmentStateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getEnvironmentState(jobId, request, requestOptions));
    }

    private async __getEnvironmentState(
        jobId: string,
        request: Api.GetEnvironmentStateRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.EnvironmentStateResponse>> {
        const { merge_mutations: mergeMutations } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (mergeMutations != null) {
            _queryParams.merge_mutations = mergeMutations.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/state`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.EnvironmentStateResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/{job_id}/state.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getWorkerReady("job_id")
     */
    public getWorkerReady(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.WorkerReadyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getWorkerReady(jobId, requestOptions));
    }

    private async __getWorkerReady(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.WorkerReadyResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/worker_ready`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.WorkerReadyResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/{job_id}/worker_ready.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.sendHeartbeat("job_id")
     */
    public sendHeartbeat(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.HeartbeatResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendHeartbeat(jobId, requestOptions));
    }

    private async __sendHeartbeat(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.HeartbeatResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/heartbeat`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.HeartbeatResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/{job_id}/heartbeat.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getActiveSession("job_id")
     */
    public getActiveSession(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.ActiveSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getActiveSession(jobId, requestOptions));
    }

    private async __getActiveSession(
        jobId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.ActiveSessionResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(jobId)}/active_session`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.ActiveSessionResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/{job_id}/active_session.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} sessionId
     * @param {Api.EvaluateRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.evaluateSession("session_id")
     */
    public evaluateSession(
        sessionId: string,
        request: Api.EvaluateRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.EvaluateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__evaluateSession(sessionId, request, requestOptions));
    }

    private async __evaluateSession(
        sessionId: string,
        request: Api.EvaluateRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.EvaluateResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/session/${core.url.encodePathParam(sessionId)}/evaluate`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.EvaluateResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling POST /env/session/{session_id}/evaluate.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} sessionId
     * @param {Api.PostEvaluationResultRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.postEvaluationResult("session_id", {
     *         success: true
     *     })
     */
    public postEvaluationResult(
        sessionId: string,
        request: Api.PostEvaluationResultRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.PostEvaluationResultResponse> {
        return core.HttpResponsePromise.fromPromise(this.__postEvaluationResult(sessionId, request, requestOptions));
    }

    private async __postEvaluationResult(
        sessionId: string,
        request: Api.PostEvaluationResultRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.PostEvaluationResultResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/session/${core.url.encodePathParam(sessionId)}/score`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.PostEvaluationResultResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/session/{session_id}/score.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} sessionId
     * @param {Api.LogRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.logMessage("session_id", {
     *         source: "source",
     *         type: "type",
     *         message: {
     *             "key": "value"
     *         },
     *         timestamp: "timestamp"
     *     })
     */
    public logMessage(
        sessionId: string,
        request: Api.LogRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.LogResponse> {
        return core.HttpResponsePromise.fromPromise(this.__logMessage(sessionId, request, requestOptions));
    }

    private async __logMessage(
        sessionId: string,
        request: Api.LogRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.LogResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `env/${core.url.encodePathParam(sessionId)}/log`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.LogResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /env/{session_id}/log.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.listSimulators()
     */
    public listSimulators(requestOptions?: ApiClient.RequestOptions): core.HttpResponsePromise<Api.Simulator[]> {
        return core.HttpResponsePromise.fromPromise(this.__listSimulators(requestOptions));
    }

    private async __listSimulators(
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.Simulator[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "env/simulators",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.Simulator[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /env/simulators.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Api.GetTestCasesRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getTestCases({
     *         simulator_name: "simulator_name",
     *         simulator_id: "simulator_id",
     *         page_size: 1
     *     })
     */
    public getTestCases(
        request: Api.GetTestCasesRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.TestCasesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getTestCases(request, requestOptions));
    }

    private async __getTestCases(
        request: Api.GetTestCasesRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.TestCasesResponse>> {
        const { simulator_name: simulatorName, simulator_id: simulatorId, page_size: pageSize } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (simulatorName != null) {
            _queryParams.simulator_name = simulatorName;
        }

        if (simulatorId != null) {
            _queryParams.simulator_id = simulatorId;
        }

        if (pageSize != null) {
            _queryParams.page_size = pageSize.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "testcases",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.TestCasesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling GET /testcases.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.getRunningSessionsCount()
     */
    public getRunningSessionsCount(
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.RunningSessionsCountResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getRunningSessionsCount(requestOptions));
    }

    private async __getRunningSessionsCount(
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.RunningSessionsCountResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "user/organization/running-sessions",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.RunningSessionsCountResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling GET /user/organization/running-sessions.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Monitor the progress of long-running operations (sandbox creation, setup, etc.) via SSE.
     *
     * **Event Flow:**
     * 1. First event: `type: "connected"` - Connection established, continue listening
     * 2. Progress events: `type: "progress"` with `message` field - Operation updates
     * 3. Completion: `type: "run_result"` or `"ssh_result"` - Operation finished
     *    - Check `success: true` for successful completion
     *    - Check `error` or `message` field if `success: false`
     * 4. Error: `type: "error"` - Operation failed, check `error` or `message` field
     *
     * **Data Format:**
     * SSE data is base64-encoded JSON. Decode it to get the OperationEvent object.
     *
     * **Client Implementation Required:**
     * - Decode base64 data from each SSE event
     * - Parse JSON to OperationEvent
     * - Check event.type and event.success to determine operation status
     * - Continue listening until receiving a terminal event (run_result, ssh_result, or error)
     * - Return success/error based on the terminal event
     *
     * **Example (pseudo-code):**
     * ```
     * for event in stream:
     *   decoded = base64_decode(event.data)
     *   operation_event = json_parse(decoded)
     *
     *   if operation_event.type == "connected":
     *     continue  # Keep listening
     *   elif operation_event.type in ["run_result", "ssh_result"]:
     *     if operation_event.success:
     *       return SUCCESS
     *     else:
     *       return ERROR(operation_event.error || operation_event.message)
     *   elif operation_event.type == "error":
     *     return ERROR(operation_event.error || operation_event.message)
     * ```
     */
    public monitorOperation(
        correlationId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<core.Stream<Api.OperationEvent>> {
        return core.HttpResponsePromise.fromPromise(this.__monitorOperation(correlationId, requestOptions));
    }

    private async __monitorOperation(
        correlationId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<core.Stream<Api.OperationEvent>>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher<ReadableStream>({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `public-build/events/${core.url.encodePathParam(correlationId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            responseType: "sse",
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: new core.Stream({
                    stream: _response.body,
                    parse: (data) => data as any,
                    signal: requestOptions?.abortSignal,
                    eventShape: {
                        type: "sse",
                        streamTerminator: "[DONE]",
                    },
                }),
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling GET /public-build/events/{correlation_id}.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Api.CreateSandboxRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.createSandbox({
     *         dataset: "dataset",
     *         plato_dataset_config: {
     *             compute: {
     *                 cpus: 1,
     *                 memory: 1,
     *                 disk: 1,
     *                 app_port: 1,
     *                 plato_messaging_port: 1
     *             },
     *             metadata: {
     *                 name: "name"
     *             }
     *         }
     *     })
     */
    public createSandbox(
        request: Api.CreateSandboxRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.CreateSandboxResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createSandbox(request, requestOptions));
    }

    private async __createSandbox(
        request: Api.CreateSandboxRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.CreateSandboxResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "public-build/vm/create",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.CreateSandboxResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling POST /public-build/vm/create.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} jobId
     * @param {Api.SetupSandboxRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.setupSandbox("job_id", {
     *         dataset: "dataset",
     *         plato_dataset_config: {
     *             compute: {
     *                 cpus: 1,
     *                 memory: 1,
     *                 disk: 1,
     *                 app_port: 1,
     *                 plato_messaging_port: 1
     *             },
     *             metadata: {
     *                 name: "name"
     *             }
     *         }
     *     })
     */
    public setupSandbox(
        jobId: string,
        request: Api.SetupSandboxRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.SetupSandboxResponse> {
        return core.HttpResponsePromise.fromPromise(this.__setupSandbox(jobId, request, requestOptions));
    }

    private async __setupSandbox(
        jobId: string,
        request: Api.SetupSandboxRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.SetupSandboxResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `public-build/vm/${core.url.encodePathParam(jobId)}/setup-sandbox`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.SetupSandboxResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling POST /public-build/vm/{job_id}/setup-sandbox.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} publicId
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.deleteSandbox("public_id")
     */
    public deleteSandbox(
        publicId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.DeleteSandboxResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteSandbox(publicId, requestOptions));
    }

    private async __deleteSandbox(
        publicId: string,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.DeleteSandboxResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `public-build/vm/${core.url.encodePathParam(publicId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.DeleteSandboxResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError("Timeout exceeded when calling DELETE /public-build/vm/{public_id}.");
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} publicId
     * @param {Api.CreateSnapshotRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.createSnapshot("public_id")
     */
    public createSnapshot(
        publicId: string,
        request: Api.CreateSnapshotRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.CreateSnapshotResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createSnapshot(publicId, request, requestOptions));
    }

    private async __createSnapshot(
        publicId: string,
        request: Api.CreateSnapshotRequest = {},
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.CreateSnapshotResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `public-build/vm/${core.url.encodePathParam(publicId)}/snapshot`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.CreateSnapshotResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling POST /public-build/vm/{public_id}/snapshot.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} publicId
     * @param {Api.StartWorkerRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.startWorker("public_id", {
     *         dataset: "dataset",
     *         plato_dataset_config: {
     *             compute: {
     *                 cpus: 1,
     *                 memory: 1,
     *                 disk: 1,
     *                 app_port: 1,
     *                 plato_messaging_port: 1
     *             },
     *             metadata: {
     *                 name: "name"
     *             }
     *         }
     *     })
     */
    public startWorker(
        publicId: string,
        request: Api.StartWorkerRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.StartWorkerResponse> {
        return core.HttpResponsePromise.fromPromise(this.__startWorker(publicId, request, requestOptions));
    }

    private async __startWorker(
        publicId: string,
        request: Api.StartWorkerRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.StartWorkerResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `public-build/vm/${core.url.encodePathParam(publicId)}/start-worker`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.StartWorkerResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling POST /public-build/vm/{public_id}/start-worker.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} publicId
     * @param {Api.SetupRootAccessRequest} request
     * @param {ApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Api.BadRequestError}
     *
     * @example
     *     await client.setupRootAccess("public_id", {
     *         ssh_public_key: "ssh_public_key"
     *     })
     */
    public setupRootAccess(
        publicId: string,
        request: Api.SetupRootAccessRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): core.HttpResponsePromise<Api.SetupRootAccessResponse> {
        return core.HttpResponsePromise.fromPromise(this.__setupRootAccess(publicId, request, requestOptions));
    }

    private async __setupRootAccess(
        publicId: string,
        request: Api.SetupRootAccessRequest,
        requestOptions?: ApiClient.RequestOptions,
    ): Promise<core.WithRawResponse<Api.SetupRootAccessResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(this._options?.headers, requestOptions?.headers);
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `public-build/vm/${core.url.encodePathParam(publicId)}/setup-root-access`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Api.SetupRootAccessResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Api.BadRequestError(_response.error.body as Api.ErrorResponse, _response.rawResponse);
                default:
                    throw new errors.ApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ApiTimeoutError(
                    "Timeout exceeded when calling POST /public-build/vm/{public_id}/setup-root-access.",
                );
            case "unknown":
                throw new errors.ApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
