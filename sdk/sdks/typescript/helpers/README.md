# Plato SDK Helpers

This directory contains **custom helper utilities** that are **NOT generated by Fern**. These files are safe to modify and will not be overwritten when regenerating the SDK.

## Purpose

The helpers provide high-level convenience functions that combine the low-level Fern-generated API client with business logic for:

- Monitoring long-running operations via SSE streams
- Waiting for sandbox operations to complete
- Handling operation success/failure states

## Files

### `SandboxMonitor.ts`
Core monitoring logic that processes SSE event streams and determines operation success/failure.

**Based on:** `sdk/services/sandbox.go` (Go implementation)

**Key Features:**
- Handles SSE event types: `connected`, `progress`, `run_result`, `ssh_result`, `error`
- Determines when operations are complete
- Provides progress callbacks
- Timeout support
- Abort signal support

### `SandboxHelpers.ts`
High-level wrapper functions that combine API calls with automatic monitoring.

**Convenience methods:**
- `createSandbox()` - Create and wait for sandbox to be ready
- `setupSandbox()` - Setup sandbox with monitoring
- `createSnapshot()` - Create snapshot with monitoring
- `startWorker()` - Start worker with monitoring
- `setupRootAccess()` - Setup root access with monitoring

## Usage

### Basic Example

```typescript
import { ApiClient, SandboxHelpers } from '@plato-sdk/typescript';

// Create client
const client = new ApiClient({
  baseUrl: 'https://plato.so/api',
  // Add auth headers, etc.
});

// Create helpers
const helpers = new SandboxHelpers(client);

// Create sandbox and wait for it to be ready
const sandbox = await helpers.createSandbox({
  dataset: 'base',
  plato_dataset_config: {
    compute: {
      cpus: 2,
      memory: 4096,
      disk: 20480,
      app_port: 8080,
      plato_messaging_port: 7000
    },
    metadata: {
      name: 'My Sandbox'
    }
  }
}, {
  onProgress: (message) => {
    console.log('Progress:', message);
  },
  timeoutMs: 600000 // 10 minutes
});

console.log('Sandbox ready!', sandbox);
```

### Advanced: Using SandboxMonitor Directly

```typescript
import { ApiClient, SandboxMonitor } from '@plato-sdk/typescript';

const client = new ApiClient({ /* ... */ });
const monitor = new SandboxMonitor(client);

// Create sandbox without waiting
const response = await client.createSandbox({ /* ... */ });
const sandbox = response.data;

// Later, monitor it manually
if (sandbox.correlation_id) {
  await monitor.waitForCompletion(sandbox.correlation_id, {
    onProgress: (msg) => console.log(msg),
    timeoutMs: 600000
  });
}
```

### Getting All Events

```typescript
const monitor = new SandboxMonitor(client);

// Get all events for debugging
const events = await monitor.waitForCompletionWithEvents(
  correlationId,
  {
    onProgress: (msg) => console.log(msg)
  }
);

console.log('All events:', events);
```

### Error Handling

```typescript
import { SandboxOperationError } from '@plato-sdk/typescript';

try {
  await helpers.createSandbox({ /* ... */ });
} catch (error) {
  if (error instanceof SandboxOperationError) {
    console.error('Operation failed:', error.message);
    console.error('Last event:', error.event);
  } else {
    console.error('Unexpected error:', error);
  }
}
```

### Create Without Waiting

```typescript
// Don't wait for operation to complete
const sandbox = await helpers.createSandbox({
  dataset: 'base',
  plato_dataset_config: config
}, {
  wait: false  // Return immediately after creating
});

// Monitor it later if needed
if (sandbox.correlation_id) {
  await helpers.getMonitor().waitForCompletion(sandbox.correlation_id);
}
```

## How It Works

### SSE Event Flow

The Plato API sends Server-Sent Events to monitor long-running operations:

1. **`connected`** - Initial connection established
2. **`progress`** - Progress updates (optional)
3. **Terminal events:**
   - **`run_result`** - Operation completed (check `success` field)
   - **`ssh_result`** - SSH operation completed (check `success` field)
   - **`error`** - Operation failed

### Event Structure

```typescript
interface OperationEvent {
  type: 'connected' | 'run_result' | 'ssh_result' | 'error' | 'progress';
  success?: boolean;    // Only present in result events
  error?: string;       // Error message if failed
  message?: string;     // Human-readable status/progress
}
```

### Success Detection

An operation is **successful** if:
- You receive a `run_result` or `ssh_result` event with `success: true`

An operation **failed** if:
- You receive an `error` event
- You receive a result event with `success: false`
- The stream ends without a terminal event
- The operation times out

## Architecture

```
┌─────────────────────────────────────┐
│   Your Application Code             │
└─────────────┬───────────────────────┘
              │
              │ Uses
              ▼
┌─────────────────────────────────────┐
│   SandboxHelpers                    │  ◄── Custom (not generated)
│   - High-level convenience methods  │
└─────────────┬───────────────────────┘
              │
              │ Uses
              ▼
┌─────────────────────────────────────┐
│   SandboxMonitor                    │  ◄── Custom (not generated)
│   - SSE event processing            │
│   - Success/failure detection       │
└─────────────┬───────────────────────┘
              │
              │ Uses
              ▼
┌─────────────────────────────────────┐
│   ApiClient (Fern-generated)        │  ◄── Generated by Fern
│   - Low-level API calls             │
│   - SSE streaming                   │
└─────────────────────────────────────┘
```

## Why Separate Files?

- **Generated code** (Client.ts, api/*) is overwritten on each `fern generate`
- **Custom helpers** (this directory) persist across regenerations
- **Clean separation** between API client and business logic
- **Easy to maintain** and extend without modifying generated code

## Regenerating the SDK

When you regenerate the SDK with `fern generate`:
- ✅ Files in `helpers/` are **preserved**
- ❌ Other files are **overwritten**

This is the recommended pattern for extending Fern-generated SDKs.

