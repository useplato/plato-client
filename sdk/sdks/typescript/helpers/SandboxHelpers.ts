/**
 * High-level helper functions for sandbox operations.
 * 
 * This file is NOT generated by Fern and provides convenient wrappers
 * around the generated API client with built-in operation monitoring.
 * 
 * Based on the Go implementation in sdk/services/sandbox.go
 */

import type { ApiClient } from "../Client.js";
import type * as Api from "../api/index.js";
import { SandboxMonitor, type MonitorOptions } from "./SandboxMonitor.js";

export interface CreateSandboxOptions extends MonitorOptions {
  /**
   * Whether to wait for the sandbox to be ready before returning.
   * If true, monitors the operation until completion.
   * Default: true
   */
  wait?: boolean;
}

export interface SetupSandboxOptions extends MonitorOptions {
  /**
   * Whether to wait for setup to complete before returning.
   * If true, monitors the operation until completion.
   * Default: true
   */
  wait?: boolean;
}

/**
 * High-level helpers for sandbox operations that combine API calls
 * with operation monitoring.
 */
export class SandboxHelpers {
  private monitor: SandboxMonitor;

  constructor(private readonly client: ApiClient) {
    this.monitor = new SandboxMonitor(client);
  }

  /**
   * Create a sandbox and optionally wait for it to be ready.
   * 
   * This is a convenience wrapper that:
   * 1. Calls createSandbox API
   * 2. If wait=true (default), monitors the operation until completion
   * 3. Returns the sandbox info
   * 
   * @param request - Sandbox creation request
   * @param options - Creation and monitoring options
   * @returns Sandbox information
   * 
   * @example
   * ```typescript
   * const helpers = new SandboxHelpers(client);
   * 
   * // Create and wait for ready (default)
   * const sandbox = await helpers.createSandbox({
   *   dataset: "base",
   *   plato_dataset_config: config
   * }, {
   *   onProgress: (msg) => console.log(msg)
   * });
   * 
   * // Create without waiting
   * const sandbox = await helpers.createSandbox({
   *   dataset: "base",
   *   plato_dataset_config: config
   * }, { wait: false });
   * ```
   */
  async createSandbox(
    request: Api.CreateSandboxRequest,
    options: CreateSandboxOptions = {}
  ): Promise<Api.CreateSandboxResponse> {
    const { wait = true, ...monitorOptions } = options;

    // Create the sandbox
    // Note: HttpResponsePromise automatically unwraps to the response type
    const sandbox = await this.client.createSandbox(request);

    // Wait for it to be ready if requested
    if (wait && sandbox.correlation_id) {
      await this.monitor.waitForCompletion(sandbox.correlation_id, monitorOptions);
    }

    return sandbox;
  }

  /**
   * Setup a sandbox and optionally wait for completion.
   * 
   * This is a convenience wrapper that:
   * 1. Calls setupSandbox API
   * 2. If wait=true (default), monitors the operation until completion
   * 3. Returns the correlation ID
   * 
   * @param jobId - Job ID of the sandbox
   * @param request - Setup request with dataset config and optional SSH key
   * @param options - Setup and monitoring options
   * @returns Setup response with correlation ID
   * 
   * @example
   * ```typescript
   * const helpers = new SandboxHelpers(client);
   * 
   * await helpers.setupSandbox("job_123", {
   *   dataset: "base",
   *   plato_dataset_config: config,
   *   ssh_public_key: publicKey
   * }, {
   *   onProgress: (msg) => console.log(msg)
   * });
   * ```
   */
  async setupSandbox(
    jobId: string,
    request: Api.SetupSandboxRequest,
    options: SetupSandboxOptions = {}
  ): Promise<Api.SetupSandboxResponse> {
    const { wait = true, ...monitorOptions } = options;

    // Setup the sandbox
    const setupResponse = await this.client.setupSandbox(jobId, request);

    // Wait for setup to complete if requested
    if (wait && setupResponse.correlation_id) {
      await this.monitor.waitForCompletion(setupResponse.correlation_id, monitorOptions);
    }

    return setupResponse;
  }

  /**
   * Create a snapshot and optionally wait for completion.
   * 
   * @param publicId - Public ID of the sandbox
   * @param request - Snapshot request
   * @param options - Monitoring options
   * @returns Snapshot response
   */
  async createSnapshot(
    publicId: string,
    request: Api.CreateSnapshotRequest,
    options: MonitorOptions = {}
  ): Promise<Api.CreateSnapshotResponse> {
    const snapshot = await this.client.createSnapshot(publicId, request);

    // Note: Snapshot operations may return a correlation_id for monitoring
    // If it does, we should monitor it
    if ('correlation_id' in snapshot && typeof (snapshot as any).correlation_id === 'string') {
      await this.monitor.waitForCompletion((snapshot as any).correlation_id, options);
    }

    return snapshot;
  }

  /**
   * Start a Plato worker and optionally wait for completion.
   * 
   * @param publicId - Public ID of the sandbox
   * @param request - Worker start request
   * @param options - Monitoring options
   * @returns Worker start response
   */
  async startWorker(
    publicId: string,
    request: Api.StartWorkerRequest,
    options: MonitorOptions = {}
  ): Promise<Api.StartWorkerResponse> {
    const workerResponse = await this.client.startWorker(publicId, request);

    // Monitor if correlation_id is provided
    if (workerResponse.correlation_id) {
      await this.monitor.waitForCompletion(workerResponse.correlation_id, options);
    }

    return workerResponse;
  }

  /**
   * Setup root access and optionally wait for completion.
   * 
   * @param publicId - Public ID of the sandbox
   * @param request - Root access setup request
   * @param options - Monitoring options
   * @returns Setup response
   */
  async setupRootAccess(
    publicId: string,
    request: Api.SetupRootAccessRequest,
    options: MonitorOptions = {}
  ): Promise<Api.SetupRootAccessResponse> {
    const setupResponse = await this.client.setupRootAccess(publicId, request);

    // Monitor if correlation_id is provided
    if (setupResponse.correlation_id) {
      await this.monitor.waitForCompletion(setupResponse.correlation_id, options);
    }

    return setupResponse;
  }

  /**
   * Get the underlying monitor for advanced use cases.
   */
  getMonitor(): SandboxMonitor {
    return this.monitor;
  }
}

