/**
 * Helper utilities for monitoring sandbox operations.
 * 
 * This file is NOT generated by Fern and contains custom business logic
 * for handling SSE streams from the Plato API.
 * 
 * Based on the Go implementation in sdk/services/sandbox.go
 */

import type { ApiClient } from "../Client.js";
import type { OperationEvent } from "../api/types/OperationEvent.js";

export interface MonitorOptions {
  /**
   * Timeout in milliseconds for the entire operation.
   * Default: 600000 (10 minutes)
   */
  timeoutMs?: number;

  /**
   * Callback for progress updates
   */
  onProgress?: (message: string) => void;

  /**
   * Abort signal to cancel the operation
   */
  abortSignal?: AbortSignal;
}

export class SandboxOperationError extends Error {
  constructor(message: string, public readonly event?: OperationEvent) {
    super(message);
    this.name = 'SandboxOperationError';
  }
}

export class SandboxMonitor {
  constructor(private readonly client: ApiClient) {}

  /**
   * Monitor a sandbox operation until completion.
   * 
   * This implements the business logic from the Go SDK (sandbox.go):
   * - Waits for terminal events (run_result, ssh_result, error)
   * - Reports progress via callback
   * - Throws on failure
   * - Returns on success
   * 
   * @param correlationId - Correlation ID from sandbox creation or setup
   * @param options - Monitoring options
   * @throws {SandboxOperationError} If the operation fails
   * @throws {Error} If the stream ends unexpectedly
   * 
   * @example
   * ```typescript
   * const monitor = new SandboxMonitor(client);
   * const sandbox = await client.createSandbox({ ... });
   * 
   * // Wait for sandbox to be ready
   * await monitor.waitForCompletion(sandbox.correlation_id, {
   *   onProgress: (msg) => console.log('Progress:', msg)
   * });
   * ```
   */
  async waitForCompletion(
    correlationId: string,
    options: MonitorOptions = {}
  ): Promise<void> {
    const { timeoutMs = 600000, onProgress, abortSignal } = options;

    // Set up timeout
    const timeoutController = new AbortController();
    const timeoutId = setTimeout(() => {
      timeoutController.abort();
    }, timeoutMs);

    // Combine abort signals
    const combinedSignal = abortSignal 
      ? this.combineAbortSignals([abortSignal, timeoutController.signal])
      : timeoutController.signal;

    try {
      // Get the SSE stream from the generated client
      // Note: HttpResponsePromise automatically unwraps to the Stream type
      const stream = await this.client.monitorOperation(correlationId, {
        abortSignal: combinedSignal,
        // Increase timeout to match the operation timeout
        timeoutInSeconds: Math.ceil(timeoutMs / 1000),
      });

      // Process events from the stream
      for await (const event of stream) {
        // NOTE: The Go implementation expects base64-encoded JSON in the SSE data field.
        // Fern's Stream class should handle the SSE parsing, but we may need to handle
        // base64 decoding if the API sends it that way. For now, assuming Fern handles it.
        
        const result = this.handleEvent(event, onProgress);
        
        if (result.shouldTerminate) {
          if (result.success) {
            return; // Success!
          } else {
            throw new SandboxOperationError(
              result.error || 'Operation failed',
              event
            );
          }
        }
      }

      // Stream ended without terminal event
      throw new Error('SSE stream ended without completion event');
    } finally {
      clearTimeout(timeoutId);
    }
  }

  /**
   * Monitor operation and collect all events.
   * Useful for debugging or detailed progress tracking.
   * 
   * @param correlationId - Correlation ID from sandbox creation or setup
   * @param options - Monitoring options
   * @returns Array of all events received
   * @throws {SandboxOperationError} If the operation fails
   */
  async waitForCompletionWithEvents(
    correlationId: string,
    options: MonitorOptions = {}
  ): Promise<OperationEvent[]> {
    const events: OperationEvent[] = [];
    
    const wrappedOptions: MonitorOptions = {
      ...options,
      onProgress: (message) => {
        if (options.onProgress) {
          options.onProgress(message);
        }
      },
    };

    try {
      const stream = await this.client.monitorOperation(correlationId, {
        abortSignal: options.abortSignal,
        timeoutInSeconds: Math.ceil((options.timeoutMs || 600000) / 1000),
      });

      for await (const event of stream) {
        events.push(event);
        
        const result = this.handleEvent(event, wrappedOptions.onProgress);
        
        if (result.shouldTerminate) {
          if (!result.success) {
            throw new SandboxOperationError(
              result.error || 'Operation failed',
              event
            );
          }
          break;
        }
      }

      return events;
    } catch (error) {
      // Still return events even on error for debugging
      if (error instanceof SandboxOperationError) {
        throw error;
      }
      throw error;
    }
  }

  /**
   * Handle a single operation event and determine if operation should terminate.
   * 
   * This implements the state machine from sandbox.go MonitorOperation():
   * - connected: Continue listening
   * - progress: Report progress, continue listening
   * - run_result/ssh_result: Terminal event, check success
   * - error: Terminal event, always failure
   * 
   * @private
   */
  private handleEvent(
    event: OperationEvent,
    onProgress?: (message: string) => void
  ): { shouldTerminate: boolean; success?: boolean; error?: string } {
    switch (event.type) {
      case 'connected':
        // Initial connection, continue listening
        return { shouldTerminate: false };

      case 'progress':
        // Progress update
        if (onProgress && event.message) {
          onProgress(event.message);
        }
        return { shouldTerminate: false };

      case 'run_result':
      case 'ssh_result':
        // Terminal event - operation completed
        if (event.success) {
          // Success!
          if (onProgress && event.message) {
            onProgress(event.message);
          }
          return { shouldTerminate: true, success: true };
        } else {
          // Failed
          const errorMsg = event.error || event.message || 'Operation failed';
          return { shouldTerminate: true, success: false, error: errorMsg };
        }

      case 'error':
        // Error event - always terminal
        const errorMsg = event.error || event.message || 'Operation error';
        return { shouldTerminate: true, success: false, error: errorMsg };

      default:
        // Unknown event type - log and continue
        console.warn('Unknown operation event type:', event.type);
        return { shouldTerminate: false };
    }
  }

  /**
   * Combine multiple abort signals into one.
   * If any signal aborts, the combined signal aborts.
   * 
   * @private
   */
  private combineAbortSignals(signals: AbortSignal[]): AbortSignal {
    const controller = new AbortController();

    for (const signal of signals) {
      if (signal.aborted) {
        controller.abort();
        break;
      }

      signal.addEventListener('abort', () => {
        controller.abort();
      });
    }

    return controller.signal;
  }
}

